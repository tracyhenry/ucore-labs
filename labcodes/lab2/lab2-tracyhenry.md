

### [练习0] 填写已有实验

- 已完成

### [练习1] 实现 first-fit 连续物理内存分配算法

- 这一个练习，主要分为四个函数。

- `default_init`: 
  - 这个函数不需要太大修改，保持原样，将nr_free清零即可
- `default_init_memmap`: 
  - 这个函数的原始实现有些错误，比如`p->flag`不能直接赋为0，因为他的PG_property位应该置为1，代表这一页可用。
  - 第二，`list_add(&free_list, &(base->page_link))`应改为`list_add_before(...)`，这样才能保证按照list_next访问链表时，物理地址是从小到大排列的。
- `default_alloc_pages`:
  - 这个函数的原始实现中，首先找一个大于等于n的页，这没有问题。但是后来它找到一个合适的页之后，就直接先把原始的连续block删掉，然后再在free_list头插入，这是完全不对的，打乱了应有的顺序。我的做法是先利用原来的大block，将空闲的插入正确的位置，再将大block删除。
  - 并且，在分配页之后，应该设置相应的reserved位，代表这些页已经被使用了。这也是原始函数没有实现的。

- `default_free_pages`:
  - 这个函数的原始实现可谓是乱成了一锅粥，所以在这里我只说明我的做法。
  - 首先，我从free_list中按照物理地址从小到大判断每个block是否能和当前要free的block前后合并，如果能合并，就合并。这个过程只要从头到尾扫一遍即可完成，并且在完成之后，base保存了合并的起始地址；
  - 接着，我利用page2pa函数，根据页的物理地址，找到base应该插入的位置，再将base插入，就完成了free_pages的任务。

- 我觉得就拿first fit算法来说，我的方法就时间复杂度来说，改进空间不太大了。
  
### [练习2]实现寻找虚拟地址对应的页表项

- 这个练习，主要实现get_pte函数，根据逻辑地址，返回二级页表项的逻辑地址。具体流程如下：
  - 找到一级页表入口：`pde_t *pdep = pgdir + PDX(la);`
  - 判断该一级页表项是否对应一个存在的二级页表，如果不存在，创建一个
  - 创建的时候，如果create为false，return NULL
  - 否则利用default_pmm.c中的alloc_page函数，分配一个物理页给这个二级页表
  - 将二级页表项链接到相应的一级页表项，并将二级页表清零
  - 利用KADDR函数返回二级页表项的虚拟地址

- 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

  - 每个PDE项的前20位用来存相应PT的物理地址（页对齐），后三位是相应的标志位
  - 每个PTE项的前20为用来存对应物理地址的前20位，后三位是标志位
  - 标志位一共有三种，PTE_P, PTE_W, PTE_U，分别代表存在位、可写位和用户可访问位。

- 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
  -mmu建立相应的一级、二级页表项，并且做好线性地址到物理地址的映射

### [练习3] 释放某虚地址所在的页并取消对应二级页表项的映射

- page_remove_pte函数的流程如下
  - 利用pte2page函数找出相应的物理页
  - 将这个页的ref减1
  - 如果这个页的ref为0，利用free_page函数释放这个页
  - 将二级页表项清零
  - invalidate快表项

- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

  - 有对应关系。Page的每一项是个物理页，在lab2中，每一个物理页和一个逻辑地址一一映射，有：Virtual Address = Physical Address + KERNBASE

- 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事。
  - 首先，在entry.S中取消段偏移
  - 接着，在boot_map_segment函数中，改变映射的方法，实现对等映射

